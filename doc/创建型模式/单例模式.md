# 单例模式
## 定义
    单例模式目的是保证在同一个进程中，同一个类有且只会生成一个对象。
### 单例种类
1. 饿汉模式： 类加载时直接创建对象。造成不必要的内存浪费
2. 懒汉模式： 调用时创建对象。可能会有同步问题。如果加锁，每次获取实例都要获取锁。会造成性能浪费。
3. DCL模式： 线程安全的，内部进行两次判断。返回实例对象需要用volatile修饰，否则会因为重排序而出现同步问题。
4. 静态内部类模式：线程安全的，线程安全由JVM保证（JVM虚拟机保证了，多个线程在加载同一个类时一定是线程安全的）
5. 枚举模式： 线程安全 + 防反射。反射会抛**IllegalArgumentException异常**。Cannot reflectively create enum objects。因为Enum是在编译阶段将Enum编译出相对应的class类。

### 饿汉式
```java
/**
 * @author jtl
 * @date 2021/7/20 11:14
 * 饿汉式单例
 * 优点：线程安全的
 * 缺点：由于类加载时就会创建对象。会造成内存浪费。
 */

public class HungrySingle {
    private static final HungrySingle S_HUNGRY_SINGLE = new HungrySingle();
    // 只要加载HungrySingle类，就会创建50M内存的数组。
    private byte[] aaa = new byte[1024*1024*50];
    
    private HungrySingle(){
    }

    public static HungrySingle getInstance(){
        return S_HUNGRY_SINGLE;
    }
}
```
### 懒汉式
```java
/**
 * @author jtl
 * @date 2021/7/20 11:41
 * 懒汉式
 * 优点：不会造成内存浪费
 * 缺点：不加synchronized可能会造成线程安全问题
 *       加 synchronized 会造成性能浪费。
 *
 */

public class LazySingle {
    private static LazySingle sLazy ;

    private LazySingle(){
        System.out.println("懒汉式："+Thread.currentThread().getName());
    }

    public static synchronized LazySingle getInstance(){
        if (sLazy==null){
            sLazy = new LazySingle();
        }

        return sLazy;
    }
}
```
### 双重检查
```java
/**
 * @author jtl
 * @date 2021/7/20 11:46
 * 双重检查模式单例
 * 优点：线程安全
 * 缺点：反射可以破坏单例
 * 注意：需加volatile，因为 new操作本身不是线程安全的。重排序会出现问题
 */

public class DCLSingle {
    private static volatile DCLSingle sDCLSingle;

    private DCLSingle() {
        System.out.println("双重检查模式：" + Thread.currentThread().getName());
    }

    public static DCLSingle getInstance() {
        if (sDCLSingle == null){
            synchronized (DCLSingle.class){
                if (sDCLSingle ==null){
                    sDCLSingle = new DCLSingle();
                }
            }
        }

        return sDCLSingle;
    }
}
```
### 静态内部类
```java
/**
 * @author jtl
 * @date 2021/7/20 11:49
 * 静态内部类单例
 * 优点：线程安全,因为类加载时是线程安全的
 * 缺点：反射可以破坏单例
 */

public class HolderSingle {
    private HolderSingle(){
        System.out.println("静态内部类单例："+Thread.currentThread().getName());
    }

    public static HolderSingle getInstance() {
        return Inner.sHolder;
    }

    private static class Inner{
        private static final HolderSingle sHolder = new HolderSingle();
    }
}
```
### 枚举
```java
/**
 * @author jtl
 * @date 2021/7/20 11:57
 * 枚举单例模式，可防反射
 */

enum EnumSingle {
    INSTANCE
}
```
