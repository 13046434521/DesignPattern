# 适配器模式
## 介绍
    将一个请求从链式的首端发出，一次传递给不同对象，知道有对象处理
    该请求为止，这样的模式称为责任链模式
## 定义
    使多个对象都有机会处理请求，避免了请求的发送者和接受者之间的耦合关系。
    将这些对象以链表的形式形成一个链，并沿着该链传递。直到有对象处理该请求为止。
## 使用场景
    多个对象都可以处理同一个请求，但具体处理请求的对象，需要运行时决定
    在请求处理者不明确的情况下，向多个对象中的一个提交请求
## UML
![责任链模式](chain.png)
## 代码
### 场景
    小明来公司一年了，想涨工资m元。于是去找了他们的组长，组长说小明想涨的数额有些太多了，要
    问人事总监，人事总监说这个他也做不了决定得问老板。
    老板看了小明想涨的工资数额后：1. 公司最近太困难了，一次性涨m元，的确做不到。
                              2. 小明你为公司做了太多的贡献，给你涨m元不是问题。
#### 抽象处理者
```java
/**
 * @author：TianLong
 * @date：2022/10/19 20:16
 * @detail：抽象处理者
 */
abstract class Handler {
    public Handler nextHandler;

    public abstract void handle(int money);
}
```
#### 实际处理者，组长
```java
/**
 * @author：TianLong
 * @date：2022/10/19 20:22
 * @detail：具体实现处理者，部门组长
 */
class Leader extends Handler{
    private int limit = 1000;
    @Override
    public void handle(int money) {
        if (money<=limit){
            System.out.println("Leader 可以给你涨："+money);
            return;
        }else{
            if (nextHandler==null){
                System.out.println("nextHandler is null");
                return;
            }else{
                nextHandler.handle(money);
            }
        }
    }
}
```
#### 实际处理者，人事总监
```java
/**
 * @author：TianLong
 * @date：2022/10/19 20:27
 * @detail：具体实现者类，人事总监
 */
class CHO extends Handler{
    private int limit = 5000;
    @Override
    public void handle(int money) {
        if (money<=limit){
            System.out.println("CHO 可以涨："+money);
            return;
        }else{
            if (nextHandler==null){
                System.out.println("nextHandler is null");
                return;
            }else{
                nextHandler.handle(money);
            }
        }
    }
}
```
#### 实际处理者，老板
```java
/**
 * @author：TianLong
 * @date：2022/10/19 20:25
 * @detail：具体实现处理者，公司老板
 */
class Boss extends Handler{
    private int limit = 10000;
    @Override
    public void handle(int money) {
        if (money<=limit){
            System.out.println("Boss 可以涨："+money);
            return;
        }else{
            System.out.println("Boss不能给你涨，你的需求"+money+"太高了");
        }
    }
}
```
#### 客户端
```java
/**
 * @author：TianLong
 * @date：2022/10/19 20:30
 * @detail：客户端
 */
class Client {
    public static void main(String[] args) {
        Leader leader = new Leader();
        CHO cho = new CHO();
        Boss boss = new Boss();
        leader.nextHandler = cho;
        cho.nextHandler = boss;

        // 直接从责任链的最底端，向leader提出申请
        leader.handle(500);
        leader.handle(2000);
        // 可以跃过leader，找CHO提出申请
        cho.handle(8000);
        leader.handle(15000);
    }
}
```
## 注意事项
    1. 对处理者和请求者，进行解耦，提供代码灵活性
    2. 如果责任链模式中的对象太多，处理请求时，由于处理请求的对象太多。最差情况下会变成对链中处理者的遍历。
    